use crate::bigint::BigInt;

#[derive(Debug, Clone)]
pub enum Token {
  Ampersand,
  AmpersandEquals,
  Asterisk,
  AsteriskEquals,
  BigIntLiteral(BigInt),
  Circumflex,
  CircumflexEquals,
  Comma,
  Colon,
  DoubleAmpersand,
  DoubleAmpersandEquals,
  DoubleAsterisk,
  DoubleAsteriskEquals,
  DoubleEquals,
  DoubleGreaterThan,
  DoubleGreaterThanEquals,
  DoubleLessThan,
  DoubleLessThanEquals,
  DoubleMinus,
  DoublePlus,
  DoubleQuestionMark,
  DoubleQuestionMarkEquals,
  DoubleVerticalLine,
  DoubleVerticalLineEquals,
  Equals,
  EndOfInput,
  Exclamation,
  ExclamationDoubleEquals,
  ExclamationEquals,
  FatArrow,
  FullStop,
  GreaterThan,
  GreaterThanEquals,
  LeftCurlyBracket,
  LeftParenthesis,
  LeftSquareBracket,
  LessThan,
  LessThanEquals,
  Minus,
  MinusEquals,
  NoSubstitutionTemplate(String, Option<String>),
  Name(Name),
  NumberSign,
  NumberLiteral(f64),
  QuestionMarkStop,
  Percent,
  PercentEquals,
  Plus,
  PlusEquals,
  QuestionMark,
  RegExp(String, String),
  RightCurlyBracket,
  RightParenthesis,
  RightSquareBracket,
  Semicolon,
  Solidus,
  SolidusEquals,
  StringLiteral(String),
  TemplateHead(String, Option<String>),
  TemplateMiddle(String, Option<String>),
  TemplateTail(String, Option<String>),
  Tilde,
  TripleEquals,
  TripleGreaterThan,
  TripleGreaterThanEquals,
  TripleStop,
  VerticalLine,
  VerticalLineEquals,
}

#[derive(Debug, Clone)]
pub enum Name {
  Await,
  Break,
  Case,
  Catch,
  Class,
  Const,
  Continue,
  Debugger,
  Default,
  Delete,
  Do,
  Else,
  Enum,
  Export,
  Extends,
  False,
  Finally,
  For,
  Function,
  If,
  Import,
  In,
  Instanceof,
  New,
  Null,
  Return,
  Super,
  Switch,
  This,
  Throw,
  True,
  Try,
  Typeof,
  Var,
  Void,
  While,
  With,
  Yield,
  // Not reserved
  Async,
  Get,
  Let,
  Meta,
  Of,
  Set,
  Static,
  Target,
  Unclassified(String),
}

impl Name {
  pub fn from_string(string: String) -> Self {
    match string.as_str() {
      "await" => Name::Await,
      "break" => Name::Break,
      "case" => Name::Case,
      "catch" => Name::Catch,
      "class" => Name::Class,
      "const" => Name::Const,
      "continue" => Name::Continue,
      "debugger" => Name::Debugger,
      "default" => Name::Default,
      "delete" => Name::Delete,
      "do" => Name::Do,
      "else" => Name::Else,
      "enum" => Name::Enum,
      "export" => Name::Export,
      "extends" => Name::Extends,
      "false" => Name::False,
      "finally" => Name::Finally,
      "for" => Name::For,
      "function" => Name::Function,
      "if" => Name::If,
      "import" => Name::Import,
      "in" => Name::In,
      "instanceof" => Name::Instanceof,
      "new" => Name::New,
      "null" => Name::Null,
      "return" => Name::Return,
      "super" => Name::Super,
      "switch" => Name::Switch,
      "this" => Name::This,
      "throw" => Name::Throw,
      "true" => Name::True,
      "try" => Name::Try,
      "typeof" => Name::Typeof,
      "var" => Name::Var,
      "void" => Name::Void,
      "while" => Name::While,
      "with" => Name::With,
      "yield" => Name::Yield,
      // Not reserved
      "async" => Name::Async,
      "get" => Name::Get,
      "let" => Name::Let,
      "meta" => Name::Meta,
      "of" => Name::Of,
      "set" => Name::Set,
      "static" => Name::Static,
      "target" => Name::Target,
      _ => Name::Unclassified(string),
    }
  }

  pub fn from_escaped_string(string: String) -> Self {
    Name::Unclassified(string)
  }

  pub fn as_string(&self) -> &str {
    match self {
      Name::Await => "await",
      Name::Break => "break",
      Name::Case => "case",
      Name::Catch => "catch",
      Name::Class => "class",
      Name::Const => "const",
      Name::Continue => "continue",
      Name::Debugger => "debugger",
      Name::Default => "default",
      Name::Delete => "delete",
      Name::Do => "do",
      Name::Else => "else",
      Name::Enum => "enum",
      Name::Export => "export",
      Name::Extends => "extends",
      Name::False => "false",
      Name::Finally => "finally",
      Name::For => "for",
      Name::Function => "function",
      Name::If => "if",
      Name::Import => "import",
      Name::In => "in",
      Name::Instanceof => "instanceof",
      Name::New => "new",
      Name::Null => "null",
      Name::Return => "return",
      Name::Super => "super",
      Name::Switch => "switch",
      Name::This => "this",
      Name::Throw => "throw",
      Name::True => "true",
      Name::Try => "try",
      Name::Typeof => "typeof",
      Name::Var => "var",
      Name::Void => "void",
      Name::While => "while",
      Name::With => "with",
      Name::Yield => "yield",
      // Not reserved
      Name::Async => "async",
      Name::Get => "get",
      Name::Let => "let",
      Name::Meta => "meta",
      Name::Of => "of",
      Name::Set => "set",
      Name::Static => "static",
      Name::Target => "target",
      Name::Unclassified(string) => string.as_str(),
    }
  }
}
